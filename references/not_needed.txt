
    # not needed
    def pull_hooks(self, start_row, start_col, direction):
        if direction == HORIZONTAL:
            (end_row, end_col) = (start_row + 1, MAX_COL)
        else:
            (end_row, end_col) = (MAX_ROW, start_col + 1)
        
        valid_hook_spots = []
        for row in range(start_row, end_row):
            for col in range(start_col, end_col):
                self.pull_valid_hook_spot(row, col, valid_hook_spots)              

        return valid_hook_spots
    # not needed
    def pull_crosswords(self, start_row, start_col, direction, rack):
        if direction == HORIZONTAL:
            (end_row, end_col) = (start_row + 1, MAX_COL)
        else:
            (end_row, end_col) = (MAX_ROW, start_col + 1)
        
        valid_crossword_score_dict = {} 
        for row in range(start_row, end_row):
            for col in range(start_col, end_col):
                 self.pull_spot_to_valid_crossword_score(row, col, direction, valid_crossword_score_dict, rack)  

        return valid_crossword_score_dict
        
    # not needed
    def pull_valid_hook_spot(self, row, col, valid_hook_spots):
        #if this is the first word placed on the board, it must start left of or above of the center spot
        if self.num_words_placed == 0:
            if row <= CENTER_ROW and col <= CENTER_COL:
                valid_hook_spots.append((row, col))
        #check if this is a blank spot 
        elif not self.has_scrabble_tile(row, col):
            #check if there is a non-blank spot on the board adjacent to it
            #TBD: has_scrabble_tile returns false if we go out of bounds...
            if self.has_scrabble_tile(row - 1, col) or \
            self.has_scrabble_tile(row + 1, col) or \
            self.has_scrabble_tile(row, col - 1) or \
            self.has_scrabble_tile(row, col + 1):                          
                valid_hook_spots.append((row, col))   
              
    # not needed
    def pull_spot_to_valid_crossword_score(self, orig_row, orig_col, orig_direction, \
                                            valid_crossword_score_dict, rack):
        #saved_shadow_tile = self.shadow_board[orig_row][orig_col]
        #dedupe the rack since we shouldn't compute the score for the same letter twice
        rack_uniq = set(rack)
        #TBD: if blank, then just compute all alphabetic letters
        for letter in rack_uniq:
            #self.shadow_board[orig_row][orig_col] = letter
            crossword_score = self.pull_valid_crossword_score(letter, orig_row, orig_col, orig_direction)
            #score of negative one means crossword is invalid
            if crossword_score != -1:
                if (orig_row, orig_col) in valid_crossword_score_dict.keys():
                    if letter in valid_crossword_score_dict.keys():
                        raise ValueError("Found a duplicate in crossword score dict")
                    valid_crossword_score_dict[(orig_row, orig_col)][letter] = crossword_score
                else:
                    valid_crossword_score_dict[(orig_row, orig_col)] = {}
                    valid_crossword_score_dict[(orig_row, orig_col)][letter] = crossword_score
      
                
                